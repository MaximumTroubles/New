Что бы не выводились теги на странице в описание, нужно выводить их {!!$product->description!!}
=== Корзина ===
=== Работа с Корзиной ===
Дополянем наш роуте , там был  - Route::get('/product/{slug}' ,[StoreController::class ,'product']); , нам надо добавить привязку к модели, перед слагом прописать название Модели
Route::get('/product/{product:slug}' ,[StoreController::class ,'product']);
А дальше надо поменять запись в методе в конетроллере , раньше метод product принимал как параметр $slug брал ее из URL, теперь нам надо прописать product(Product $product) - имя Модели и  в переменной будет лежать уже конктреный обьект товара на который мы перешли , его слаг будет браться автоматически как из обьекта, так как мы его указали в роуте.
И теперь нам не надо делать

Создаем на стрнице товара форму которая будет отправлять количество покупак товара и сам товар, в скрытом инпуте отправляем какой id товара который ложим в корзину
Дальше у нас есть нексколько вариант как и куда отправлять данные из формы:

- session - если пользователь не залогинен то хоробы хранить в сессии у пользователя на компе:
Сессия это асс массив мы будет рабоать именно с ним
- DB - если пользователь вошел тогда записываем в базу связывая с его id

- cookie - не подходит так как они получаються в каждом запросе

Дальше стал вопрос как мы будет данные отравлять обычной формой или Ajax запросом что без перезагрузки страницы

=== Ajax ===
Форме задаем класс
{!! Form::open(['class' => 'form-add-to-cart']) !!}
Для проверить в главном шаблоне на налачие в хеде метатега
<meta name="csrf-token" content="{{ csrf_token() }}">
Проверяем подключение файла с js скриптами в низу шаблона

И дальше уже создаем в папке js новый файл cart.js  и require его в основной файл app.js и запускаем npm run watch
О боги, этот js я его тупо не знаю, разпишу тут все по шагово

Создали конст с этой формой
const formAddToCart  = document.querySelector('.form-add-to-cart')
Далие проверяем ее
if(formAddToCart){
    formAddToCart.addEventListener('submit', (e)=> {     - добавили обработчик события submit , стрелочная функция в нее передали е - событие так как это обьект
        e.preventDefault(); - тут уже отменили стандртное дейтсвие (тоесть когда мы нажимаем на кнопку buy страница перестала обновляться )
        const data = new FormData(formAddToCart); - тут создаем переменную data = новому обекту формДата к оторый мы передаем нашу форму и втроенная в js команада FormData собирает нам обьект из наших переданных в форме данных
        прим.
        product_id: 1
        qty : 2
        И дальше ее передает в axios и так как мы ее передаем постом То и в метода Контроллера нужно их получить в помощью класса Request $request и можеь вывести id покупаемного товара  return $request->product_id; и посмотреть все там же где и 123 (описанно ниже)
        axios.post('/cart/add',data); - тут мы прописываем что форму будем отправлять посмтом по такой то сылки
    })
}
Нам надо создать контроллер корзины
Дальше идем в роутс и нам надо прописать пути:
Route::post('/cart/add' ,[CartController::class ,'add']);
Внутри нового конетроллера создали новый метод add - для теста прописали там return 123
Дальше нажимаем на кнопку buy - заходим в консоль разработчика в вкладку network там выбираем отсортировать XHR и там будет нащ запрос add переходим в него и там есть вкладка preview и смотрим там будет отработан наш метод add а тоесть цыфры 123


=== Та же корзина на 18 недели ===
Окей тут такое дело , для работы с корзиной нам нужен функцииональный контроллер в котором будет прописанна логика работы корзины, у нас уже есть обычный конетроллер CartController в нем мы не будем писать фукции нам нужно создать свой Сервис Корзины CartService.php, создаем под это все отдельную папку в которой будут лежать такие вот Сервивы -> папка Services.
Дальше в этом файле прописываем namespace и создаем класс CartService
Дальше продумываем функионал самой корзины и создаем методы которые будут за них отвечать

Первый метод add добовлние товара и его количества в корзину , метод принимает add(Product $product, $qty) - сам товар и его колочество мы получаем из Контроллера который передает данные в метод

Так же создаем метод clear удаление всех товаров из корзины


Дальше метод remove удаление одного товара , передаем туда $id товара

И конечно же изменение количества товара в корзине changeQty - передавать сюда будем $id и $qty - новое количество товара

Еще один метод это totalSum() - для подсчета общей стоимости товаров


Тут стоит вопрос как мы этот класс CartService будем использовать в конетроллере?

=== Знакомство с Facades ===
в php   есть такеи магические методы как __callStatic($method, $arg) -> он вызываеться тогда когда надо вызвать какой то Статический метод и указываем (название статического метода и аргуметы его )
в нутри метода уже создаеться новый образец  класса который мы хотим вызвать {
    $instance(переводиться как образец) = new CartService
    $instance->$method($arg) - и тут уже вызываеться этот метод с его аргументами

Но мы будем пользоваться фукциионалом который есть у Laravel:
Мы создаем Facade в папке app> создаем новую папку Facades и внутри создаем файл Cart.php
Как обычно прописываем namespace и создаем класс Cart extandes Facade(который Illuminate\Support\Facades\Facade; ){
    В это классе Facade есть уже реализованный метод
    protected static function getFacadeAccessor(){
        return 'Cart'; - этот метод должен возвращать нам название этого Фасада  И подключать в контроллер мы уже будет не CartService а этот фасад Cart И вызывать там уже как статический метод  прим. Cart::add()
    }
}
Дальше нам же этот фасад нужно как то связать с CartService.
Для этого идем в app>Providers>AppServiceProvider в методе boot() привязывем его:
$this->app->bind('Cart',CartService::class); - это говорит о том что когда мы будем обращаться к классу(фасаду) Cart на самом деле мы будем обращаться к CartService, это для того что б кажый раз не создовать обект класса как я рассписал выше в __callStatic()    Не забыть подключить сверху

Вроде как все вся подготовка выполнена , теперь и может идти в конетроллер и от туда передавать данные в методы сервиса данные через фасад
Cart:add(Product::findOrFail($request->product_id, $request->qty)); Тут мы обратились к методу сервиса CartService add(Product $product, $qty) и в его аргументы передеали id продукта которого запросили в базе данных по данным получиних из $request в который попдает данные формы отправленые из старницы где карточка товара при нажатие на кнопку купить.
В CartService в методе add проверили что туда доходят эти данные их можно вывести с помощью dd() и глянуть там же в панели разработчика.

Данные корзины мы будет хранить в сессии.
В сервисе в методе add прописываем Session - это такой же фасад так что его нужно так же сверху подключить
use Illuminate\Support\Facades\Session;
У Session есть разные методы один из них для записии в нее put() - сессия это массив ассоциативный , для запини нужно предоставить правильно данные. Для этого нужно понимать какие данные нам надо там хранить, а хранить надо те , которые мы будет выводить в корзине для пользователя
прим.
'cart' =>[  - все это данные которые будут храниться в сессии с именнем cart
   '1' => [   - Ключем массива надо сделать id товара для удобного удаление и поиска в массиве его значений
    'id' => 1,
    'price' => 100,
    'qty' => 1,
    'name' => Product,
    'img' => '',
],
   '2' => [
    'id' => 1,
    'price' => 100,
    'qty' => 1,
    'name' => Product,
    'img' => '',
],
 ]                         - товарах может быть много в корзине, каждый товар это массив и все товары вместе это тоже массив

Пишем это в метод add CartService
Записывать этот массив в сессию надо вот так:
$data = [
            'id' => $product->id,
            'name' => $product->name,
            'price' => $product->price,
            'img' => $product->img,
            'qty' => $qty,
];
Session::put('cart.' . $prodcut->id, $data) - Когда мы пишем 'cart(точка)1' - мы обращаемся к первому элементу массива. в нашем случаии мы подключили $id товара и передали переменную в которой массив данных которые передаем в корзину.

Вот мы понажимаем на кнопку в сессию продукты запишуться но мы не где не увидим это
Так что нам надо создать представление, из boostrap мы взяли модальное окно и вставили в нащ проект, там есть кнопка отдельно ее я встал в меню на иконку корзины просто взял от туда:
<a href="#" data-bs-toggle="modal" data-bs-target="#exampleModal">

и само окно вставили в самый низ стараницы после footera  и там есть в центральной части class="modal-body"
внутри него мы @include('_store.parts._cart')
Дальше идем и создаем этот cart :
В представлении что бы получить что то из сесси достаточно написать session()
Поэтому создаем цыкл
if(session('cart'))  - если пуста тогда корзина пуста , если что то есть то выводим что то
 Создаем таблцу для красивого отображение товаров
 и foreach(session('cart') as $product) - перебираем массив и получаем каждый продукт отдельно, так как получим мы опять массив по этому выводить надо так $product['img'] и так далие

else
  <p>Ваша корзина пуста</p>
endif

Что бы увидить товар надо его добавить обновить старницу и открыть корзину , надо это пофиксить.
Фиксить мы это идем в JS  тут будет инфа 1:53:28



Дальше у нас проблема с тем что когда нажимаем на товар еще раз добавить он не суммируеться, фиксим:
У сессии метод get проверяем на наличии в сессии уже такго id если есть тогда
if( Session::get('cart.'.$product->id) ){
    Нам надо узнать сколько там едениц товара , создаем переменную $oldQty = Session::get('cart.'. $product->id.'.qty'); - выглядит это так cart.11.qty - это вложеность массива:
    'cart' => [
        11 =>[
            'qty' => 3  -  в переменную $oldQty записываем цыфру 3
        ]
    ]
    И дальше перезаписываем значение qty в сессии
    Session::put('cart.'.$product->id.'.qty', $oldQty + $qty);
}
else{
Иначе просто как раньше создаем новый
}

Дальше прописываем метод public static function totalSum(){ - cделать надо его статическим, так как мы будет пользоваться им внутри класса CartService.
    $total = 0; создали переменную
    foreach(Session::get('cart') as $product){ - Перебираем всю сессию карт
        total += $product['price'] * $product['qty']; - в переменную записываем прибавление каждой цены умноженой на колово товара
    }
    Session::put('totalSum',$total) - Для удобства вывода и что б не трогать сессию cart создаем новую сессию и записываем туда общую сумму.
    И теперь надо не забывать выводить эту функцию там где нам надо например в методе add в конце надо добавить  self::totalSum(); Ну и конечно же ввывести в представление {{session('totalSum')}}

}

Все это подченяеться понятию шаблон проектирования
https://refactoring.guru/ru





